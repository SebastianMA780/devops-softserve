pipeline { // This MUST be 'pipeline' with a lowercase 'p' at the start.
    agent any

    // No 'tools' block is used here.
    // The pipeline relies on a 'python' executable being available in the agent's PATH,
    // and then creates and uses a dedicated virtual environment for the build.

    stages {
        stage('Checkout SCM') {
            steps {
                script {
                    // Checkout the latest code from your SCM into the workspace.
                    checkout scm
                    echo "Repository checked out."
                }
            }
        }

        stage('Setup Python Environment') {
            steps {
                script {
                    // We'll create the venv and install dependencies from the workspace root
                    // because requirements.txt is at the root.
                    dir('.') { // Changed to root directory
                        echo "Setting up Python virtual environment..."

                        // Create venv in a dedicated directory at the root, e.g., '.venv_test'
                        // This avoids polluting 'app' directly with venv files.
                        sh 'python -m venv .venv_test'

                        // Define the path to the Python executable within the newly created virtual environment.
                        def venvPythonExecutable = "./.venv_test/Scripts/python"

                        echo "Installing basic Python packages (pip, pytest) into the virtual environment..."
                        // Use the full path to the virtual environment's python to install packages.
                        sh """
                            "${venvPythonExecutable}" -m pip install --upgrade pip
                            "${venvPythonExecutable}" -m pip install pytest
                        """

                        echo "Installing dependencies from requirements.txt (located at root)..."
                        // IMPORTANT: Explicitly set environment variables for PostgreSQL 17 paths.
                        // This includes setting PG_CONFIG and explicitly passing include/lib dirs to pip.
                        withEnv([
                            "PG_MAJOR=17", // Specify PostgreSQL major version
                            "PG_VERSION=17.0", // Specify full PostgreSQL version (adjust if different)
                            "PGHOME=C:/Program Files/PostgreSQL/17", // Base installation directory
                            "PATH+POSTGRESQL=C:/Program Files/PostgreSQL/17/bin", // Add bin to PATH
                            "INCLUDE=C:/Program Files/PostgreSQL/17/include", // Add include to INCLUDE path
                            "LIB=C:/Program Files/PostgreSQL/17/lib", // Add lib to LIB path
                            // CRITICAL: Explicitly tell psycopg2-binary where to find pg_config
                            "PG_CONFIG=C:/Program Files/PostgreSQL/17/bin/pg_config.exe" // Point to PG17's pg_config
                        ]) {
                            sh """
                                if [ -f requirements.txt ]; then
                                    # Use --global-option to pass arguments directly to setup.py's build_ext
                                    "${venvPythonExecutable}" -m pip install -r requirements.txt \\
                                        --global-option="build_ext" \\
                                        --global-option="-I${env.PGHOME}/include" \\
                                        --global-option="-L${env.PGHOME}/lib"
                                    echo "Dependencies installed from requirements.txt"
                                else
                                    error "ERROR: requirements.txt not found at the repository root! Cannot install dependencies."
                                fi
                            """
                        }
                        echo "Python environment setup complete."
                    }
                }
            }
        }

        stage('Run Python Tests') {
            steps {
                script {
                    // Set PYTHONPATH for the entire stage using withEnv.
                    // This ensures the PARENT directory of 'app' is on the Python module search path.
                    withEnv(["PYTHONPATH=${env.WORKSPACE}"]) {
                        dir('.') { // Current working directory is now C:\ProgramData\Jenkins\.jenkins\workspace\flask-app-python-tests
                            echo "Verifying test files exist in 'Tests/' directory..."
                            // List contents of the 'Tests' directory to confirm file presence and casing
                            sh 'ls -lR Tests/'

                            echo "Attempting to collect Python tests with pytest (--collect-only)..."
                            // Path to the Python executable in the venv, now relative to the root.
                            def venvPythonExecutableAtRoot = "./.venv_test/Scripts/python"

                            // Use --collect-only to diagnose collection issues separately from execution.
                            // Add -s to prevent output capture, and -vv for very verbose output during collection.
                            // Any import errors or test setup issues during collection should show up here.
                            sh """
                                "${venvPythonExecutableAtRoot}" -m pytest --collect-only -s -vv Tests/ --ignore=.venv_test/ -p no:warnings
                            """

                            echo "Running Python tests with pytest..."
                            // This step will run the actual tests. It might fail if collection still yields 0 items.
                            sh """
                                "${venvPythonExecutableAtRoot}" -m pytest --verbose Tests/ --ignore=.venv_test/ -p no:warnings
                            """
                            echo "Python tests completed."
                        }
                    }
                }
            }
        }

        // Optional: Add a stage for linting/code quality checks
        // stage('Code Quality Check') {
        //     steps {
        //         script {
        //             withEnv(["PYTHONPATH=${env.WORKSPACE}"]) { // Also set PYTHONPATH for linting if needed
        //                 dir('.') { // Or dir('app') if flake8 should scan only the app directory
        //                     echo "Running Flake8 for code quality..."
        //                     def venvPythonExecutableAtRoot = "./.venv_test/Scripts/python"
        //                     sh """
        //                         "${venvPythonExecutableAtRoot}" -m pip install flake8
        //                         "${venvPythonExecutableAtRoot}" -m flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
        //                         "${venvPythonExecutableAtRoot}" -m flake8 . --count --exit-zero --max-complexity=10 --max-line-length=120 --statistics
        //                     """
        //                     echo "Code quality check completed."
        //                 }
        //             }
        //         }
        //     }
        // }
    }

    post {
        always {
            script {
                // Clean up the virtual environment regardless of build success or failure.
                // The 'venv' is located in the root directory.
                dir('.') { // Changed to root directory
                    echo "Cleaning up Python virtual environment..."
                    sh 'rm -rf .venv_test' // Deletes the '.venv_test' directory
                    echo "Virtual environment removed."
                }
            }
            echo 'Python testing pipeline finished.'
        }
        success {
            echo '✅ Python application tests passed successfully!'
        }
        failure {
            echo '❌ Python application tests failed. Check logs above.'
        }
    }
}